# Bitcoin Infrastructure

## Introduction 
Introduction to Bitcoin Infrastructure is focused on providing students with a solid understanding of the role that nodes and node operators play in the construction of the network. In particular it will focus on the incentives that drive enterprise operators to spend large sums of money to build and operate their infrastructure.

## Course Outline
Chapter 1: The instructions

Chapter 2: Rules and their enforcement

Chapter 3: Transactions, payment channels and mempools

Chapter 4: Block assembly

Chapter 5: The small world network

Chapter 6: Conclusion


## Chapter 1: The Instructions 
The Bitcoin white paper defines the network's protocol specifications stipulating the one and only type of node found in Bitcoin. 
**These nodes are often referred to as miners**, and are characterised by an ability to **produce blocks, distribute blocks to peers (other nodes), and validate received blocks**.

Merely running the open source BitcoinSV node software does not make a machine a Bitcoin node. If the system is not upholding the consensus mechanism of the network based on block publication and proof-of-work, it’s not a node. 

In Bitcoin’s initial stages, a home computer could act as a node producing valid blocks by performing the Proof of Work (PoW) process using a desktop grade CPU. As the difficulty of the PoW increased, GPUs and then Application Specific Integrated Circuits (ASICs) became necessary equipment to remain competitive.

As bitcoin scales, the difficulty of the PoW and transaction throughput of the network increases. This makes it necessary to invest in specialised hardware and systems including server grade systems and high bandwidth network interfaces to validate the transactions that are included in each block, as well as large numbers of networked ASIC hashing machines to perform the energy intensive process of Proof of Work process.

Most nodes typically run software called "bitcoind" however there is no requirement to use any specific software. Nodes can run whatever software allows them to participate in the network by producing valid blocks.

The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work. This timestamping function is the main role of nodes on the network. It is their job to collate, validate, process and store all of the actions taking place on the network globally and in real-time by placing them into blocks which are then added to the chain via the competitive proof-of-work process. With each block added to the chain, winning participants are awarded payment.

Bitcoin uses a proof of work system in the process of mining. In order for a block to be accepted, the broadcasting node must demonstrate valid proof of work which covers all of the data in the block.

1. The proof of work algorithm attempts to solve a puzzle with a low probability of success per trial.

2. A Miner uses a candidate block header as the input hashes it, then checks whether the hash value is below a target. If it's not, the Miner changes the nonce in the block header and hashes it again. Once the Miner finds a hash value below the target, validates the block, distributes the block to the rest of the miners on the network, and then those miners start the proof-of-work process again referencing this blockhash in their new header template, the block has been successfully mined.

3. The difficulty of this process is adjusted to limit the rate at which new blocks can be generated by the network. Due to the very low probability of successful generation, it is impossible to predict which node will generate the next block.

4. The low probability of successfully finding valid proof of work solutions reduces the likelihood that two or more Miners generate a block around the same time.


Proof of work is a function of a node operator’s ability to invest in the network and acts as a means for other nodes to ensure that the information they are receiving was validly generated by another node. In this, it acts as a gating function applying an up-front cost to any attempt to suggest a new block.

This cost incentivises nodes to participate honestly; only proposing honest blocks.

Importantly, proof of work does not prevent anyone from spinning up a node, or trying to extend the chain. However, it means that anyone wanting to participate must invest in the network and the infrastructure needed to maximise their chance of success.


### Steps to run the network
The steps to run the network are as follows:
1. New transactions are broadcast to all nodes.
2. Each node collects new transactions into a block.
3. Each node works on finding a difficult proof-of-work for its block.
4. When a node finds a proof-of-work, it broadcasts the block to all nodes.
5. Nodes accept the block only if all transactions in it are valid and not already spent.
6.Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.

By collectively following these instructions, nodes are incentivised to find ways to develop their own competitive advantage, and by doing so, their investments in hardware and network infrastructure allows the network to scale efficiently. The network's incentives are structured such that the most honest, open, and capable participants are the most likely to be rewarded.

The network is designed like this so attacks are not economically viable and thus unsustainable.

It is important for nodes to ensure that every other node on the network has knowledge of every transaction, as it is the precursor step to telling other nodes the positional index of the transaction in the node’s block template. Selfishly, this may sometimes mean nodes have knowledge of transactions they don't intend to timestamp, and sending them to any other nodes that don’t have them in the interest of making the propagation of a found block, i.e. adding a new block to the blockchain and earning the reward for doing so, more efficient.

The economic incentives that drive nodes to comply with this instruction ensure nodes can

a) validate another node’s proposed block quickly, and
b) have any blocks they discover validated by other nodes as quickly as possible.



### Step 3: Each node works on finding a difficult proof-of-work block
The process of finding a proof-of-work is done by specialised machines called ASIC miners (Application Specific Integrated Circuit) or ‘hashers’, and is typically governed by an intermediate control system called a ‘Pool Miner’. Nodes distribute key information about the incomplete block to the pool miners who use it to manage one or more hashers in the search for a valid proof-of-work.

Hashers attempt to solve a puzzle by performing the process of ‘hashing’ a provided block header -- modifying and iterating through nonce (number used once) values within the block header -- until they find a block header that hashes to a number less than a specified target number (difficulty target). The block templates to which have been hashed the most have the highest probability of being valid.

Each puzzle has a random outcome, and the frequency of solutions found, the block discovery rate, is ‘self tuned’ by the network to stay as close to 10 minutes as possible. The 10 minute block interval keeps the number of orphan blocks low, while still giving ample opportunity (2016 possible blocks every 2 weeks) for nodes to compete in the process of ordering the ledger. 

10 minutes was chosen as having longer block times would result in fewer competing nodes, while shorter block times would result in more orphan races. This means there are approximately 2016 blocks added to the Bitcoin blockchain every 2 weeks, creating a cap on the number of block winning nodes.

The valid hash puzzle is a type of impediment that makes it impossible to generate valid block proposals for anyone without access to hashers providing an extremely simple means by which nodes can determine whether they are talking to another node. A node wants to know who the other nodes in the network are so that they can efficiently share transactions and block announcements. The act of winning a block shows that a particular node is a valid competitor. In the not too distant future, it's likely nodes will establish high bandwidth, low latency communications with each other to optimise communication.

Proof of Work (PoW) is designed to ensure that only node operators who have  invested significant time and money in equipment and infrastructure can participate in the network. This significant investment also ensures node operators are easily identifiable enterprise level actors who are required to process transactions as a corporate activity under law.

The Bitcoin network is considered financial infrastructure, and as such the maintainers and operators of that infrastructure will be accountable for how it is managed and used. Finding a valid solution for the hash puzzle as part of PoW is indeed an energy intensive process; however, this energy expenditure is independent from the overhead needed to gather and validate the transactions in each block. This means that as Bitcoin scales, its per-transaction efficiency increases.

For example, if the difficulty stays the same but transaction throughput increases by a factor of 10, then the same amount of Proof of Work can secure 10 times as many transactions. This however, is where additional investments in memory, network connectivity, and storage are necessitated by the nodes to handle the UTXO set.

It can be said that the network must trend towards a scenario where the outcome is such that the total energy spent per transaction on proof of work is worth a tiny fraction of the fee paid on that transaction. With Bitcoin’s micro fees, this would typically represent a very small amount of energy. This outcome takes some time to eventuate, but is borne from the economic incentives behind proof of work and the mining process.

### Step 4: When a node finds a proof-of-work, it broadcasts the block to all nodes
When a node solves the puzzle, it must also propagate the solution to all other nodes on the network as quickly as possible. This is to minimise the chance that a competing node will also find their own valid proof-of-work and propagate it to the network; sparking what is known as an ‘Orphan Race’.

When analysing this directive, it is important to also look at what is in a block so we can understand how much information needs to be transmitted across the network. In its full form, a block is a set of all transactions in the Merkle Tree plus the block header.

These blocks represent an incorruptible record of valid transactions. In this way, we can consider the chain of blocks as a chronologically ordered set of timestamps. The process of using proof of work gives the network an ideal method to control the cadence of these timestamps; with each node operating as part of a distributed, leaderless time-stamping service.

Again, it can be said the system will trend towards having nodes that are not just exceptionally well connected, but also actively share their computed block and other transaction lists with as many other nodes as possible to ensure they have the knowledge needed to accept and validate any proof of work solution extremely quickly.

This incentive to share information will be the primary impetus for increasing the density of the ‘small world network’ that forms in the centre of the overall network, and will be a huge driver influencing a node operators’ expenditure on networks and research and development into faster and more effective ways to connect.



### Step 5: Nodes accept the block only if all transactions in it are valid and not already spent
This is a big part of the user security model. Allowing Bitcoin users to accept a node’s confirmation that a transaction they have broadcast has been accepted and is considered valid by a majority of block producers, removes any need for users to wait on block confirmation for the transaction’s timestamp to be officially recorded; enabling almost instant transaction clearing and settlement.

This instruction clearly outlines the node’s need to validate the contents of the block against its own knowledge of what exists on the ledger and the rules in place governing the protocol. If a node receives a block that contains an invalid transaction, the block cannot be accepted as valid. For example, if the node receives a block that contains a transaction that spends an already used output, the transaction is invalid and the block must be rejected because spendable outputs on the ledger can only be used once

The rule also defends against malicious actors who try to create invalid transactions on the ledger by ensuring nodes are incentivised to validate all transactions.

Similarly, nodes will always reject a transaction that attempts to re-spend a used input regardless of whether the first seen transaction is already in a block or not. In this way, if a transaction’s input is already used, the Bitcoin user should see a response from at least one node indicating the newly introduced transaction was rejected as a double spend. If this ever happens, the user is instantly made aware there is something wrong with the transaction. Although this can happen occasionally due to user error or platform design nodes have robust processes in place to quickly disconnect any nefarious nodes or network peers that are trying to propagate double spends.



### Step 6: Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash
As soon as a node has received and validated a new block from one of its competitors, it is incentivised to build its new block template using that block’s hash. This has the effect of each subsequent block being added into a chain of valid proof of work.

This means beginning the process of clearing validated transactions out of the mempool* and preparing the next block’s Merkle tree. Doing any form of work on a superseded block becomes wasted effort as soon as with another node's block proposal is disseminated and validated; creating the incentive to be hyper aware of other nodes and any blocks they discover.

This hyper awareness will have the effect of reducing the potential of orphan races, making the network more efficient and reducing the amount of work done producing valid blocks that don’t form part of the longest valid chain of proof-of-work.

Keep in mind, nodes have the freedom to reject blocks on any basis, and it might eventuate that a group of nodes on the network determine that a particular subset of nodes are not following lawful order to generate a correction on the ledger.

Nodes follow Nakamoto Consensus which is used to set and act upon any rules agreed to by the operators of that group of nodes. Bitcoin’s traceability and incentive structure produces outcomes where the most honest, lawful action is the most profitable in the long term.

**The mempool is a data structure containing the set of valid transactions that the node accepted but which have not yet been timestamped in a block**




## Chapter 2: Rules and their enforcement
The first section took us through the directives outlined in the white paper for how nodes should operate the network. When looking closely at these directives, there has to be a way for each node to know that the transactions or blocks which they are receiving from other network peers are valid. This is done with a series of protocol rules which are enforced by the collective participants in the block building process. 

Proposed transactions and blocks can be broadcast into the network from anywhere and can originate from a system that is honest or malicious. Transactions represent a request to inscribe new information onto the ledger including both arbitrary data used in higher order systems, as well as updated ownership information over Bitcoin tokens, which can in turn themself, represent higher order tokens and exchangeable objects. Blocks represent a timestamping event across a topologically ordered collection of transactions and occur at a rate which is automatically controlled by node operators. Nodes work to ensure that only valid transactions and blocks are accepted onto the network. This is managed through a series of checks to ensure information presented in the protocol conforms to a certain set of rules. Each node applies the rules as part of its role in operating the network.

Broadly, the are broken down into the following rulesets:

Consensus rules:
- Block consensus rules
- Transaction consensus rules
- Script language rules

Standard local policies:
- Standard local transaction policies
- Standard local script language policies
- Standard local P2P network policies

Each event received by a node must be evaluated against these rule sets before being accepted or propagated to other nodes.



### Consensus Rule 
The consensus rules are codified into the Bitcoin node client software system and represent fixed and unchangeable rules applied across the network. These rules must be strictly adhered to in order for a node using the client to actively participate in the network governance process. 

The immutable rules are a set of rules that define the format and constraints that transactions and blocks must follow. Making any changes to these rules could cause nodes to disagree on the nature of Bitcoin. All agreements are enforced through application of proof of work by nodes in a process known as Nakamoto Consensus.

Since 2009, aspects of the protocol have been either changed or removed. The Bitcoin SV philosophy is that where aspects of these rules have been changed in the past they should be returned to be as close to the original rules as possible and then “set in stone”. In some cases this has resulted in divergence with the original protocol including minor changes to the scripting language.

The only further changes needed are the return to the original difficulty readjustment algorithm and re-enablement of the last remaining script opcodes plus some spare opcodes if the need ever arises to allow changes to protect the security of the network. This could be things such as the  addition of a new hash function or a more secure digital signature algorithm.

This section details the role of nodes in the network and also how nodes resolve any conflicts in agreement on the state of the Ledger. Nodes vote to enforce the rules used to build the blocks that make up the Bitcoin public ledger and define an honest node as a node that seeks out the longest valid chain of blocks and applies proof of work to extend that chain.



### Block consensus rules no. 1

#### Block Size Rule
When a block is found, there is an economic limit applied to the block size, which is imposed by nodes on the network. This allows nodes to reach consensus on behavioural limits of the network. This limit is set to a large multiple of typical demand.

The size of a block is the size in bytes of the serialised form of the block, including the block header and all of the transactions it includes.


This rule is a configurable consensus rule meaning that node operators set the limit. As a group, they are expected to reach consensus on this value and configure it manually.

There is no default value for this setting, and the current BitcoinSV node client software will not start without the operator setting a value. Nodes that are configured with different values to the rest of the network risk having their blocks rejected, or rejecting blocks that other nodes accept, leaving them stuck working on a nonviable chain-tip.



#### Block Subsidy Rule
The block subsidy will drop by half at a scheduled rate of every 210,000 blocks, starting with a subsidy of 5,000,000,000 satoshis per block from the genesis block, rounding down when sub-integer fractions are encountered.


This rule defines the rate at which Bitcoins are released onto the network from the original issuance. This rule means that nodes who create blocks are rewarded Bitcoins which have not been previously circulated. It is the means by which the entire supply of Bitcoin is released onto the ledger. The subsidy distribution rate was codified in the first ever version of the Bitcoin client.

Nodes who try to issue extra bitcoins to themselves outside of this so-called ‘inflation schedule’ violate the rule that defines how many bitcoins are in existence and as such their blocks must be rejected as invalid. Nodes must adhere to this rule, or their blocks will be judged as invalid by the other participants in the network.

Interestingly, blocks which fail to reward tokens from the subsidy or tokens paid by transaction creators as fees to the winning miner are still considered valid, and the satoshi tokens which aren’t included in the final reward are withheld from circulation. While this is uncommon, it has happened in the past, collectively resulting in a cumulative loss of over 1000 Bitcoins since the network was first formed.



### Proof of Work Target Adjustment Rule
The network will adjust the target for the difficulty of the Proof of Work needed for a valid block to maintain an approximate 10 minute block discovery rate

This rule defines how the network adjusts the target difficulty rate as the available resources being applied to proof-of-work increases over time. The discovery of a block is a pseudorandom process in which nodes compete to check as many combinations of nonce and block header to try to find a value which is equal to or less than a difficulty value that is algorithmically determined by the network. The system makes periodic adjustments to re-define the difficulty rate based on the period of discovery of previous blocks. In the original release of Bitcoin this value was calculated once every 2016 blocks, or approximately every 2 weeks. However, in 2017 the method of calculation was changed to one which recalculates the difficulty target after every block. 

There is a commitment from node operators to revert the network back to the 2016-block adjustment cycle from the original implementation. Because this is an immutable rule, this will require a network wide upgrade to take place in which all nodes will accept the modified consensus conditions simultaneously.



### Genesis Block Rule
Only blocks that add to the block chain formed by building upon the Genesis block are valid

This rule states that blocks must be added to an unbroken chain of proof of work leading back to the genesis block, which has its block hash hard coded into the Bitcoin node client’s software. This prevents a malicious party somehow creating a new chain in order to perpetrate a malicious redirection of hashpower or economic activity, and is an important aspect of Simplified Payment Verification, allowing users to check they are using the correct chain of blocks with minimal overhead.

The genesis block is identified using its block hash which is 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f. By ensuring all users of the network are aware of this block hash, there can be certainty around which chain of blocks is valid. If a user or node connects to a chain of blocks which leads back to a point of origin that is not the genesis block, it can know immediately that it has connected to the wrong network.



### Transaction consensus rules no. 1
The length is the number of bytes in the serialized transaction. This rule allows miners to collectively set a practical limit for users on the size of a transaction. As the capabilities of nodes and node software improve this limit will rise, providing added utility to all network users.



### Use of nLockTime and nSequence
The nSequence fields of every transaction input and the nLockTime field of the transaction collectively determine the “finality” of a transaction. If a transaction is “non-final” then it can not be valid but it can become “final” at a later time. If a transaction is “final” then it can be included in a block.

The interpreter will evaluate nSequence and nLocktime as per the following:

- If the value of nSequence of a transaction input is 0xFFFFFFFF then that input is a “final input”.
- If the value of nSequence of a transaction input is not 0xFFFFFFFF then that input is a “non-final input”.
- **If all of the inputs of a transaction are “final inputs” then the transaction is “final”, irrespective of the value of the nLockTime field.**

- If one or more of the inputs of a transaction are “non-final inputs” then:
    - If the value of the transaction’s nLockTime field is less than 500,000,000 then the field represents a block height.
    - If the node is working on a block whose height is greater or equal to the value of this field, then the transaction is “final”.
Otherwise the transaction is “non-final”.
If the value of the transaction’s nLockTime field is greater or equal to 500,000,000 then the field represents a UNIX epoch timestamp.
If the median time passed of the last 11 blocks is greater or equal to the value of this field, then the transaction is “final”.
Otherwise, the transaction is “non-final”.
Only a “final” transaction may be confirmed in a block.

A new transaction must replace a prior “non-final” transaction if it has the same inputs in the same order, every sequence number for every input in the new transaction is not less than the sequence number for the corresponding input in the prior transaction, and the sequence number of at least one input in the new transaction is greater than the sequence number for the corresponding input in the prior transaction.

If a new transaction is detected which does not fulfill all of these requirements then it must be rejected.

If a new transaction is detected which has inputs that conflict with the inputs of a “non-final” transaction, but which are not identical to the inputs of the “non-final” transaction, then the “non-final” transaction is the “first seen” transaction and takes priority over the new transaction.



### The sum of the value of the inputs of a transaction must be greater than or equal to the sum of the values of the outputs.
When transactions are created in Bitcoin, they must spend what are known as ‘Unspent Transaction Outputs’ (UTXOs). UTXOs are the live coins available to be spent on the network. The ledger represents the cumulative transaction history of those coins from their distribution as part of the block reward. Every node has a set of UTXOs it manages which it curates according to the operator’s chosen local policies.

**Each UTXO holds a quantity of bitcoin satoshi tokens locked in a script. When the locking script is successfully executed in the script engine using an unlocking script, the satoshi tokens are released to be spent**. 

**To be successful, the full script must terminate with a single non-zero value remaining on the stack.** The transaction then re-allocates the satoshis to new outputs which themselves become UTXOs, replacing their predecessors in the current UTXO set across the network.

If a transaction tried to create outputs that cumulatively represent more value than the inputs it would be spending, it would be creating new satoshi tokens which is expressly forbidden by the rules. In this way the number of tokens usable on the network remains fixed over time, with tokens only distributed on to the ledger as a reward to node operators in the initial bootstrap phase of the network.



### Transaction Format Rule
Transactions must conform to the data formatting rules of the Bitcoin protocol, including respecting the sizes of certain fields and their encoding schemas.

The currently accepted versions of the Bitcoin transaction serialisation rules specify the format in a very specific manner, as outlined below.

Transaction version - A value defining the version of the protocol that should be used to evaluate the transaction (4 bytes).
The number of inputs being spent (VARINT (link this to https://wiki.bitcoinsv.io/index.php/VarInt ), 1, 3, 5 or 9 Bytes).
Each of the inputs themselves which are each comprised of the following:
TXID of the transaction containing the UTXO being spent (32 Bytes).
The VOUT index of the UTXO (4 Bytes).
A field defining the length of the unlocking script, or scriptSig (VARINT, 1, 3, 5 or 9 Bytes).
The scriptSig needed to spend the input.
The scriptSig’s sequence number, which is used in the creation and use of payment channels (4 Bytes).
The number of outputs being created (VARINT (link this to https://wiki.bitcoinsv.io/index.php/VarInt ), 1, 3, 5 or 9 Bytes).
The outputs themselves which are each comprised of the following:
The value in satoshis being locked into the output script (8 Bytes).
A field defining the length of the scriptPubKey (VARINT, 1, 3, 5 or 9 Bytes).
The output scriptPubKey or locking script.
nLockTime which is the time at which the transaction outputs can be spent. If the transaction has an input with a non-final sequence number and an nLockTime in the future, it is considered to be inside a payment channel. These transactions cannot be included in a block until the sequence number is final or nLockTime expires, either of which closes the payment channel. The transaction can be updated by submitting a new valid version with an increased nSequence value for at least one of the non-final inputs

While these rules are rigid and uniformly applied across all current transaction versions, there is significant flexibility within the rules. The hard limits imposed by the protocol itself allow for a transaction to create up to 2^64 outputs, with each output able to express a length field large enough to insert up to 18 Exabytes of data. These limits are theoretical of course, with limitations on actual usage being framed by the economic reality faced by nodes in the operation of the system.



### Script language rules no. 1
The Bitcoin scripting language and its specification
One of the aspects of Bitcoin which gives it such a broad range of applicability and function is its scripting language. Based on Forth, the language is stack based and uses Reverse Polish Notation as the means to enter and process data. While the language appears simple, when used properly it can provide a Turing complete environment within which complex and diverse applications can be built.

The scripting language is made up of a set of 186 opcodes which each instruct operations on the processing stack. Any node that wishes to process transactions on the Bitcoin network must ensure that their node client implementation is processing each of the opcodes in a way that exactly matches the outcomes expected by every other node on the network at that time, including whether or not those opcodes are enabled or not.

Even a minor change in the way opcodes are processed can result in transactions that were committed to the ledger being rendered unspendable and causing irreparable damage to the system’s integrity and usability. It is because of these reasons that it is of vital importance that every node processes each opcode in the script in exactly the same manner.
Interestingly, this also means that bugs that existed in the execution algorithms must also be upheld. Notably, a bug in the OP`_`CHECKMULTISIG opcode requires that an extra data item be added to the stack before the first signature or the opcode will fail to execute properly. For this reason, anyone spending an output with OP`_`CHECKMULTISIG in it must add one extra data item to their script. Additionally, any node clients that did not take this known bug into account would incorrectly validate scripts that use the opcode, potentially causing them to reject transactions or blocks that should be considered valid, or accepting transactions and blocks which the rest of the network considers invalid.

The following rules are applied for all transactions.

#### Data Types
All data items in Bitcoin Script are a byte sequence. Some operations interpret their parameters as numeric or boolean values and require the item to fulfil the specifications of those types. Some operations produce items on the stack which are valid numeric or boolean values.
A byte sequence has a length and a value. The length of the byte sequence must be an integer greater or equal to zero and less than or equal to 2^32-1 (UINT32_MAX).

The byte sequence of length zero is called the “null value”.

Any data item can be interpreted as a boolean value. If the data item consists entirely of bytes with value zero, or the data item is the null value, then the boolean value of the item is false. Otherwise, the boolean value of the item is true.

A data item can be interpreted as a numeric value. The numeric value is encoded in a byte sequence using little-endian notation. When script items are processed using opcodes that perform mathematical functions, the node will treat any byte sequence of up to 7500 bytes long as a numeric value, allowing for 'bignum' calculations to be performed in script.



### Formal Grammar for Bitcoin Script
The Formal Grammar for Bitcoin Script is set by node operators. This contains the full set of approved opcodes and their exact spelling and function.

It’s also worth highlighting the following features of this formal grammar:

- The complete script consists of two sections, the unlocking script (scriptSig) and the locking script (scriptPubKey). The locking script is from the transaction output that is being spent, while the unlocking script is included in the transaction input that is spending the output.
- Current consensus rules state that an unlocking script can only contain the first 96 opcodes, which allow constants and data to be pushed onto the stack. This requirement is a part of the Validity of Script Consensus Rule, defined later.
- A branching operator (OP`_`IF or OP`_`NOTIF) must have a matching OP_ENDIF.

- An OP`_`ELSE can only be included between a branching operator and OP`_`ENDIF pair. There can only be at most one OP`_`ELSE between a branching operator and an OP`_`ENDIF.

- OP`_`RETURN may appear at any location in a valid script. The functionality of OP`_`RETURN has been restored and is defined later in the section OP`_`RETURN Functionality. Grammatically, any bytes after an OP`_`RETURN that is not in a branch block are not evaluated and there are no grammatical requirements for those bytes.

- Note that disabled operations are part of this grammar. A disabled operation is grammatically correct but will produce a failure if executed.



### Validity of Script Rule
The locking and unlocking scripts for every input of a transaction must be grammatically valid, as defined by the formal grammar rules from the previous page.

Also note that the scripts must be grammatically valid when they are spent. It is not required that the output scripts of a transaction are grammatically valid although it is highly recommended that client software implement this restriction as a policy.

The unlocking scripts used in transaction inputs may only contain PUSHDATA operations, as defined by the formal grammar above.

Currently, the following 5 opcodes are disabled: OP`_`2MUL, OP`_`2DIV, OP`_`VER, OP`_`VERIF, OP`_`VERNOTIF.



### Numeric Value Size Rule
For a byte sequence to validly represent a numeric value, the length of the byte sequence must be less than or equal to 750,000 bytes. A byte sequence that is larger than this is a valid byte sequence but is not a valid numeric value.


Note that while some operations require parameters to be valid numeric values, they may produce byte sequences which are not valid numeric values (for example, OP_MUL may produce a byte sequence which is too large to validly represent a numeric value).



### Stack Memory Usage Rule
The stack memory usage consensus rule limits the amount of memory that can be used on the stacks. This rule is evaluated against the sum of the memory used by the stack and the alt-stack.

If the execution of the unlocking and locking script for an input uses more memory than defined in this rule, then the transaction is 


